const[state,dispatch] = useReducer(reducer, initialState);

Whatâ€™s Happening?
We call useReducer with two things:
reducer â†’ The function that handles state updates
initialState â†’ The initial state value { count: 0 }
useReducer gives us two things in return:
state â†’ The current state value (starts as { count: 0 })
dispatch â†’ A function we can use to send actions to the reducer

When you call:
const [state, dispatch] = useReducer(reducer, initialState);
React handles a few things behind the scenes:
useReducer automatically calls your reducer function the first time with:
state set to initialState
action set to undefined (ignored on initial render)

But what if you later decide to track more data, like a username or status? Youâ€™d need to rewrite a lot of code.

Quick Recap:
Using an object for initialState keeps your code flexible and scalable. 
React automatically initializes state with initialState when useReducer is called.
action.type allows more powerful and descriptive actions, making your reducer extensible.

ðŸ‘‰ Using action.type is a common pattern in state management (like Redux) because it:
Allows the action object to carry extra information if needed.
Makes it easier to extend the action with more data.

USECALLBACK
These react Hook returns a memoized callback function
Thatâ€™s memoization! Itâ€™s a way to make programs run faster by remembering answers to repeated requests or questions.
In coding, memoization stores results of expensive function calls and returns the cached result when the same inputs occur again. 
Caching is a system design concept that involves storing frequently accessed data in a location that is easily and quickly accessible.
Itâ€™s super useful in cases where the same calculation happens repeatedly.

