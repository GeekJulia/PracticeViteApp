const[state,dispatch] = useReducer(reducer, initialState);

Whatâ€™s Happening?
We call useReducer with two things:
reducer â†’ The function that handles state updates
initialState â†’ The initial state value { count: 0 }
useReducer gives us two things in return:
state â†’ The current state value (starts as { count: 0 })
dispatch â†’ A function we can use to send actions to the reducer

When you call:
const [state, dispatch] = useReducer(reducer, initialState);
React handles a few things behind the scenes:
useReducer automatically calls your reducer function the first time with:
state set to initialState
action set to undefined (ignored on initial render)

But what if you later decide to track more data, like a username or status? Youâ€™d need to rewrite a lot of code.

Quick Recap:
Using an object for initialState keeps your code flexible and scalable. 
React automatically initializes state with initialState when useReducer is called.
action.type allows more powerful and descriptive actions, making your reducer extensible.

ðŸ‘‰ Using action.type is a common pattern in state management (like Redux) because it:
Allows the action object to carry extra information if needed.
Makes it easier to extend the action with more data.

USECALLBACK
These react Hook returns a memoized callback function
Thatâ€™s memoization! Itâ€™s a way to make programs run faster by remembering answers to repeated requests or questions.
In coding, memoization stores results of expensive function calls and returns the cached result when the same inputs occur again. 
Caching is a system design concept that involves storing frequently accessed data in a location that is easily and quickly accessible.
Itâ€™s super useful in cases where the same calculation happens repeatedly.

useCallback allows us to isolate resource intensive functions so that they will not automatically run on every render.
The useCallback Hook only runs when one of its dependencies update.
This can improve performance.
it returns a memoized function
A component using the useState hook does re-render even if props havenâ€™t changedâ€”as long as state changes

 When Should You Use useCallback?
useCallback is useful for:
Passing functions to child components that rely on reference equality (e.g., React.memo).
Avoiding unnecessary re-renders in large lists or complex UIs.
Optimizing performance in components that re-render often.
âš¡ Donâ€™t Overuse It! Using useCallback can be counterproductive if your component isnâ€™t expensive to re-render. 
Itâ€™s best for components that perform heavy calculations or re-render frequently.

Quick Recap:
useCallback memoizes a function to prevent it from being recreated unnecessarily.
It helps with performance optimization by preventing child components from re-rendering.
Use it when passing functions as props to child components.
Only re-creates the function if dependencies change.